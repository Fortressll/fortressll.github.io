<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小乐的博客</title>
    <link>https://fortressll.github.io/</link>
    <description>Recent content on 小乐的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright (c) 2008 - 2014, Steve Francia; all rights reserved.</copyright>
    <lastBuildDate>Sat, 14 Sep 2019 13:53:50 +0800</lastBuildDate>
    
	<atom:link href="https://fortressll.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode-155.最小栈(Min Stack)</title>
      <link>https://fortressll.github.io/post/leetcode155/</link>
      <pubDate>Sat, 14 Sep 2019 13:53:50 +0800</pubDate>
      
      <guid>https://fortressll.github.io/post/leetcode155/</guid>
      <description>采用语言为Java
 LeetCode国内官网：https://leetcode-cn.com
 因为题号和题名都有，题目描述就不写了
  简单难度 155.最小栈(Min Stack) 解法一 题目要求设计一个栈，于是开始造轮子，定义数组作为栈，其他部分按照题目要求一点一点写就好，注意要判断是否溢出，这也是很麻烦的一点，因为数组长度定义不好的话，提交时只要测试用例够长就会溢出
import java.util.EmptyStackException; class MinStack { private int[] array; private int top; private final static int size = 10000; /** initialize your data structure here. */ public MinStack() { array = new int[size]; top = -1; } public void push(int x) { if (top == size - 1) { throw new StackOverflowError(); } else { array[++top] = x; } } public void pop() { if (top == -1) { throw new EmptyStackException(); } array[top] = array[top+1]; top--; } public int top() { if (top == -1) { throw new EmptyStackException(); } return array[top]; } public int getMin() { if (top == -1) { throw new EmptyStackException(); } int min = array[0]; for (int i = 1; i &amp;lt;= top; i++) { if (array[i] &amp;lt; min) min = array[i]; } return min; } }  执行用时：132ms 内存消耗：47.</description>
    </item>
    
    <item>
      <title>Leetcode-20.有效的括号(Valid Parentheses)</title>
      <link>https://fortressll.github.io/post/leetcode20/</link>
      <pubDate>Fri, 13 Sep 2019 14:54:31 +0800</pubDate>
      
      <guid>https://fortressll.github.io/post/leetcode20/</guid>
      <description>采用语言为Java
 LeetCode国内官网：https://leetcode-cn.com
 因为题号和题名都有，题目描述就不写了
  简单难度 20.有效的括号(Valid Parentheses) 本题用到了栈，isMatch用来判断括号是否匹配，遍历字符串，如果是左括号则入栈，否则判断是否为空，为空则直接返回false
栈的目的是在遍历中，一个右括号如果能和栈顶括号匹配则出栈，最终如果栈不为空，返回false即可
import java.util.Stack; class Solution { public boolean isMatch(char l, char r) { return (l == &#39;[&#39; &amp;amp;&amp;amp; r == &#39;]&#39;) || (l == &#39;(&#39; &amp;amp;&amp;amp; r == &#39;)&#39;) || (l == &#39;{&#39; &amp;amp;&amp;amp; r == &#39;}&#39;); } public boolean isValid(String s) { Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;Character&amp;gt;(); if (s.length() % 2 != 0) { return false; } for (int i = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>Leetcode-14.最长公共前缀(Longest Common Prefix)</title>
      <link>https://fortressll.github.io/post/leetcode14/</link>
      <pubDate>Thu, 12 Sep 2019 13:12:11 +0800</pubDate>
      
      <guid>https://fortressll.github.io/post/leetcode14/</guid>
      <description>采用语言为Java
 LeetCode国内官网：https://leetcode-cn.com
 因为题号和题名都有，题目描述就不写了
  简单难度 14.最长公共前缀(Longest Common Prefix) 这个写的有点乱了哈哈哈，先求出数组中最短元素的长度，后面只需遍历最短长度就可以了
class Solution { public String longestCommonPrefix(String[] strs) { String same = &amp;quot;&amp;quot;; if (strs.length == 1) { return strs[0]; } else if (strs == null || strs.length == 0) { return &amp;quot;&amp;quot;; } else { int min = strs[0].length(); for (int i = 1; i &amp;lt; strs.length; i++) { if (strs[i].length() &amp;lt; min) min = strs[i].length(); } for (int i = 0; i &amp;lt; min; i++) { for (int j = 1; j &amp;lt; strs.</description>
    </item>
    
    <item>
      <title>Leetcode-9.回文数(Palindrome Number)</title>
      <link>https://fortressll.github.io/post/leetcode9/</link>
      <pubDate>Wed, 11 Sep 2019 19:45:31 +0800</pubDate>
      
      <guid>https://fortressll.github.io/post/leetcode9/</guid>
      <description>采用语言为Java
 LeetCode国内官网：https://leetcode-cn.com
 因为题号和题名都有，题目描述就不写了
  简单难度 9.回文数(Palindrome Number) 本来看完题目不想用转字符串数组的方法做来着，但是想了会还是没想出来数学方法，先做了再说
还是一个low,一个high，判断数组对应位置是否相等
class Solution { public boolean isPalindrome(int x) { char[] str = (&amp;quot;&amp;quot;+x).toCharArray(); int high = str.length-1; for (int low = 0; low &amp;lt;= high; low++) { if(str[low] != str[high-low]) return false; } return true; } }  执行用时：19ms 内存消耗：39.1MB</description>
    </item>
    
    <item>
      <title>Leetcode-7.整数反转(Reverse Integer)</title>
      <link>https://fortressll.github.io/post/leetcode7/</link>
      <pubDate>Wed, 11 Sep 2019 11:25:57 +0800</pubDate>
      
      <guid>https://fortressll.github.io/post/leetcode7/</guid>
      <description>采用语言为Java
 LeetCode国内官网：https://leetcode-cn.com
 因为题号和题名都有，题目描述就不写了
  简单难度 7.整数反转(Reverse Integer) 该题要求将目标值反转，比如123转为321，主要是数学问题
我们可以设置一个值last，从个位数开始保存，依次加入十位数、百位数等
class Solution { public int reverse(int x) { long last = 0; while (x != 0) { last = last * 10 + x % 10; x /= 10; } if (last &amp;lt; Integer.MIN_VALUE || last &amp;gt; Integer.MAX_VALUE) { last = 0; } return (int)last; } }  执行用时：3ms 内存消耗：34.1MB</description>
    </item>
    
    <item>
      <title>一起看论文-Stacked Hourglass Networks for Human Pose Estimation</title>
      <link>https://fortressll.github.io/post/paper/</link>
      <pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fortressll.github.io/post/paper/</guid>
      <description>之前看过一段时间论文，在这里做下简单的记录和大家分享一下，做的ppt有阵日子了，所以可能会忘记个别图片的出处，如果有幸被作者看到了，请联系我删除~
So，let&amp;rsquo;s get started!
 本篇主要和大家分享一下关于人体姿态估计方面的论文，主要以ppt加少量描述的形式呈现
 总觉得我的博客用的主题有点问题，图片很小，需要看细节只能麻烦Crtl+鼠标滚轮放大了
  论文题目：Stacked Hourglass Networks for Human Pose Estimation  附上论文：https://arxiv.org/abs/1603.06937 附上代码(tensorflow版本，原版为Lua语言)：https://github.com/wbenbihi/hourglasstensorlfow  可以看到整体网络结构是由多个hourglass(沙漏)状的块组成，文章中多次提到bottom-up和top-down，对应高分辨率到低分辨率和从低分辨率到高分辨率，起初理解总是搞反，总觉得bottom to up直译应该是低到高，后来才发现自己的错误。该网络结构像沙漏，在图中能体现出它对称的特点。
接下来介绍几个文章中的重要知识点，先是Residual Module(残差块)和Heat Map(热图)。上图中的小图代表一个残差块，下边大图是一个更加详细的绘制，图源实在找不到了抱歉，可以看到穿插了三个Batch Normalization(绿色部分)和三个Relu(红色部分)。
上图即为Heat Map(热图)，可以看到有对关节点的预测，论文中对热图介绍不多，所以如想做更多了解还得Google了。
上图是一个四阶Hourglass模块，可以先跳过此图看下图中的一阶Hourglass，之后再回来能够加深理解，图中每个方块都代表一个Residual残差块。
接下来就是文中的主题Hourglass了，它的主要作用就是要捕捉每个尺度下地特征，图中就是一个Hourglass模块，蓝色Res代表Residual(残差块)，绿色为Max Pool(最大池化)层，红色部分为Up Sample(上采样)。大致可以从Hourglass模块总结出四个特点：1.可以看到在池化之前，向上分出了一个残差块，它的作用就是保留原尺度的信息，因为通过池化后会发生变化 2.上采样之后会将该处的信息和之前支线残差块出来的信息做一个相加 3.每两次降采样之间，会用一个残差块来提取特征，此图中并没有体现，因为它是一个一阶Hourglass，下图会展示一个四阶Hourglass结构，仔细对比可以发现这个特点 4.每两次相加操作之间会有一个残差块用于提取特征，同样参照下图
上图为一个四阶的Hourglass模块，其实就是在满足上述四个特点的基础上做了四次叠加(将一阶Hourglass图中虚线框内部分替换为一个一阶Hourglass就可以得到二阶结构)
Intermediate Supervision模块，暂译为中间监督，它的目的是对所有的Hourglass模块进行预测。图中沙漏状的就是Hourglass，每一个热图都会计算loss，蓝色部分就是热图的位置，其余部分均为卷积层。
至此，各模块大致介绍已结束，附上整个网络结构图，可以看到从输入开始，依次经过卷积层，批量归一化加Relu、残差块、池化层，再经过两个残差块后就是重复的模块了，本文用来8个这样的重复结构，和热图那里是一个结构。
训练细节如上图所示，本篇论文初看好像不是很难理解，但是还是建议对应相应的代码去自习扣一扣细节，可能会有不一样的认识。原文中的代码是Lua语言的，因为不是很了解Lua，所有我在Github上找到了Tensorflow版本的，也就是用Python语言的，慢慢啃还是由很多收获，希望大家可以去看一看，链接放在本篇开头部分，就这样~</description>
    </item>
    
    <item>
      <title>LeetCode-1&amp;&amp;167.两数之和(Two Sum)相关</title>
      <link>https://fortressll.github.io/post/leetcode1/</link>
      <pubDate>Mon, 09 Sep 2019 17:30:13 +0800</pubDate>
      
      <guid>https://fortressll.github.io/post/leetcode1/</guid>
      <description>心血来潮想学习刷刷LeetCode，从简单难度开始吧,采用的语言为Java
 附上LeetCode国内官网：https://leetcode-cn.com
 因为题号和题名都有，题目描述就不写了
  简单难度 1.两数之和(Two Sum) 遍历一下，看看哪两个数字相加等于我们的目标值，返回他们的数组下标就可以了
class Solution { public int[] twoSum(int[] nums, int target) { int[] output = new int[2]; for (int i = 0; i &amp;lt; nums.length; i++) { for (int j = i + 1; j &amp;lt; nums.length; j++) { if (nums[i] + nums[j] == target) { output[0] = i; output[1] = j; } } } return output; }  执行用时：72ms 内存消耗：38.</description>
    </item>
    
    <item>
      <title>关于小乐</title>
      <link>https://fortressll.github.io/post/my-first-blog/</link>
      <pubDate>Mon, 09 Sep 2019 16:57:30 +0800</pubDate>
      
      <guid>https://fortressll.github.io/post/my-first-blog/</guid>
      <description>我的小小博客总算是开了，本应该在本科阶段就写写的，一直拖到了现在真是惭愧。平时可能会做点老师的小项目当当苦力，代码和学术方面能力都不怎么样，所以这个博客就作为一个学习的记录吧哈哈哈~欢迎互关微博或者加我的微信，希望可以向大家学到更多东西~</description>
    </item>
    
  </channel>
</rss>